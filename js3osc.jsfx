desc:JS3Osc
tags: synth, instrument

slider1:maxpoly=16<2, 32, 1>-Polyphony

slider2:osc1_vol=-12<-60, 0, .01>Volume
slider3:osc1_wave=0<0, 5, 1{Sine,Triangle,Saw,Square,Pulse,Noise}>Osc1 Wave
slider4:osc1_phase_offset=0<-1,1,0.01>Osc1 Phase Offset
slider5:osc1_phase_det=0<-100, 100, 1>Osc1 Phase Detune
slider6:osc1_coarse=0<-24, 24, 1>Osc1 Coarse
slider7:osc1_fine=0<-99, 99, 1>Osc1 Fine
slider8:osc1_pan=0<-1, 1, 0.01>Osc1 Pan
slider9:osc1_inv=0<0, 1, 1{No, Yes}>Osc1 Invert phase

slider30:env_att=1<1, 10000, 1:log>Attack
slider31:env_dec=1<1, 10000, 1:log>Decay
slider32:env_sus=0<-90, 0, .1:log>Sustain Db
slider33:env_rel=500<1, 10000, 1:log>Release

slider35:pitch_amt=0<-24,24,0.1>Pitch amount
slider36:pitch_att=1<1, 10000, 1:log>Pitch Attack
slider37:pitch_dec=1<1, 10000, 1:log>Pitch Decay
slider38:pitch_rel=500<1, 10000, 1:log>Pitch Release

import 3o.adsr.jsfx-inc
import 3o.array.jsfx-inc

options:gfx_hz=60

@init

poly.array_init(0, 128, 5); // [note, velocity, freq, phase-left, phase-right]
envelope = 2000; // 128 * 7 buffer for keys adsr
remove_ptrs.array_init(4000, 128, 1);
pitch_env = 5000; // 128 * 7 buffer for pitch adsr

function wrap(number) (number <= 1 ? number : number - 1;);
function sine_wave(cycle) (sin(cycle * 2 * $pi););
function tri_wave(cycle) (
  cycle < 0 ? (
    4 * cycle + 2 - 1;
  ) : (
    cycle > 0.5
      ? 4 * cycle - 2 - 1
      : -4 * cycle + 2 - 1;
  );
);
function saw_wave(cycle) (
  cycle < 0
  ? cycle * -2 - 1
  : cycle * -2 + 1;
);
function square_wave(cycle) (
  cycle < 0 ? (
    cycle < -0.5 ? -1 : 1;
  ) : (
    cycle < 0.5 ? -1 : 1;
  );
);
function pulse_wave(cycle) (
  cycle < 0 ? (
    cycle < -0.25 ? -1 : 1;
  ) : (
    cycle < 0.25 ? -1 : 1;
  );
);
function make_noise() (rand(2) - 1;);
function db2gain(db) (10^(db / 20););
function round(in) (floor(in + 0.5 * sign(in)););
function note2freq(n) (440 * pow(2, (n - 69) / 12););
function freq2note(f) ( round(12*(log(f/440)/log(2))+69); );

function make_wave(wave, cycle) (
  wave == 0 ? sine_wave(cycle)
    : wave == 1 ? tri_wave(cycle)
    : wave == 2 ? saw_wave(cycle)
    : wave == 3 ? square_wave(cycle)
    : wave == 4 ? pulse_wave(cycle)
    : make_noise();
);

@block

while (midirecv(offset, msg1, note, vel)) (
  event = msg1 & 0xF0;
  channel = msg1 & 0x0F;

  // Note on
  event == 0x90 && vel ? (

    // remove note if it is already playing
    note_repeat = 0;
    ptr = poly.array_find(note);
    ptr >= 0 ? (
      note_repeat = 1;
      last_phasel = ptr[3];
      last_phaser = ptr[4];
      poly.array_remove(ptr);
    );

    // if polyphony is full and not mono remove first element
    poly.size == maxpoly && maxpoly != 0 ? (
      poly.array_remove(poly.array_first());
    );

    ptr = poly.array_add();
    ptr[0] = note;
    ptr[1] = vel / 127;
    ptr[2] = note2freq(note) / srate;
    ptr[3] = note_repeat ? last_phasel : 0; // osc start phase left
    ptr[4] = note_repeat ? last_phaser : 0; // osc start phase right

    env = envelope + note * 7;
    adsr_seta(env_att * 0.001, env);
    adsr_setd(env_dec * 0.001, env);
    adsr_sets(exp(log(10)/20 * env_sus), env);
    adsr_setr(env_rel * 0.001, env);
    adsr_a(vel / 127, env);

    env = pitch_env + note * 7;
    adsr_seta(pitch_att * 0.001, env);
    adsr_setd(pitch_dec * 0.001, env);
    adsr_sets(1, env);
    adsr_setr(pitch_rel * 0.001, env);
    adsr_a(1, env);
  );

  // Note off
  event == 0x80 || (event == 0x90 && !vel) ? (
    ptr = poly.array_find(note);
    ptr >= 0 ? (
      adsr_r(envelope + note * 7);
      adsr_r(pitch_env + note * 7);
    );
  );

  // All notes off
  event == 0xB0 && note == 123 ? (
    poly.array_clear();
  );

  midisend(offset, msg1, note, vel);
);

@slider
osc1_gain = db2gain(osc1_vol);
osc1_st_det = pow(2, osc1_phase_det / 1200); // stereo detune
osc1_fine_det = pow(2, osc1_fine / 1200);
osc1_coarse_det = pow(2, osc1_coarse / 12);

@sample

outl = 0;
outr = 0;
remove_ptrs.array_clear();
ptr = poly.array_first();
while(ptr >= 0) ( // for each note/voice

  envbuf = envelope + ptr[0] * 7;
  env_state = adsr_process(envbuf);
  pitchbuf = pitch_env + ptr[0] * 7;
  adsr_process(pitchbuf);
  
  // OSC1
  osc_pitch_det = pow(2, pitchbuf[0] * pitch_amt / 12);
  osc_det = osc1_coarse_det * osc1_fine_det * osc_pitch_det;
  ptr[3] = wrap(ptr[3] + ptr[2] * osc1_st_det * osc_det); // phase left
  ptr[4] = wrap(ptr[4] + ptr[2] / osc1_st_det * osc_det); // phase right
  wave_l = make_wave(osc1_wave, wrap(ptr[3] + osc1_phase_offset * 0.25));
  wave_r = make_wave(osc2_wave, wrap(ptr[4] - osc1_phase_offset * 0.25));
  spl0 += wave_l * (1 - osc1_pan) * envbuf[] * osc1_gain;
  spl1 += wave_r * (1 + osc1_pan) * envbuf[] * osc1_gain;

  // mark note for deletion
  env_state == 0 ? (
    p = remove_ptrs.array_add();
    p[0] = ptr[0];
  );

  ptr = poly.array_next(ptr);
);

// remove notes that finished adsr
ptr = remove_ptrs.array_first();
while(ptr >= 0) (
  p = poly.array_find(ptr[0]);
  p >= 0 ? poly.array_remove(p);
  ptr = remove_ptrs.array_next(ptr);
);

//freq = 220;
//
//osc_det = osc1_coarse_det * osc1_fine_det;
//cyclel = wrap(cyclel + freq / srate * osc1_st_det * osc_det);
//cycler = wrap(cycler + freq / srate / osc1_st_det * osc_det);
//wave_l = make_wave(osc1_wave, wrap(cyclel + osc1_phase_offset * 0.25));
//wave_r = make_wave(osc1_wave, wrap(cycler - osc1_phase_offset * 0.25));
//
//spl0 += wave_l * osc1_gain;
//spl1 += wave_r * osc1_gain;
